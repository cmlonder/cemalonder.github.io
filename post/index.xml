<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Cemal Önder</title>
    <link>http://cemalonder.com/post/</link>
      <atom:link href="http://cemalonder.com/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 13 Jan 2020 07:14:38 +0300</lastBuildDate>
    <image>
      <url>http://cemalonder.com/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>http://cemalonder.com/post/</link>
    </image>
    
    <item>
      <title>Welcome Back Clean Code</title>
      <link>http://cemalonder.com/post/welcome-back-clean-code/welcome-back-clean-code/</link>
      <pubDate>Mon, 13 Jan 2020 07:14:38 +0300</pubDate>
      <guid>http://cemalonder.com/post/welcome-back-clean-code/welcome-back-clean-code/</guid>
      <description>&lt;p&gt;I recently read an 
&lt;a href=&#34;https://overreacted.io/goodbye-clean-code/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;article&lt;/a&gt; from Dan Abramov who is the creator of Redux.
Even if I agree his article point:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t be a clean code zealot. Clean code is not a goal. It’s an attempt to make some sense out of the immense complexity of systems we’re dealing with.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I don&amp;rsquo;t agree how misleading his article title and how not descriptive his example. Because this kind of titles &amp;ldquo;Goodbye Clean Code&amp;rdquo;
gives power to another kind of zealots who hates some Software Principles or hates someone around him mentioning this kind of
principles. When you title your article like this, it is too easy being used as a power in social medias to be offensive against
software principles just by mentioning your article without any arguments to use with your own. Also think about how many people exist who
never know Clean Coding principles but using your article just as a weapon against it instead of his own experiences.
Rather I like the people who has deep knowledge of Clean Coding and Refactoring and can give some advice where to use them
properly and giving me awareness of it (which is probably aim of this article but I find it misleading and insufficient)&lt;/p&gt;
&lt;p&gt;Just for an idea, you can google &amp;ldquo;OOP sucks&amp;rdquo; or ironically &amp;ldquo;Goodbye Redux&amp;rdquo; to see
how zealots use this kind of titles where I both like OOP and Redux.&lt;/p&gt;
&lt;p&gt;Dan mentions 2 points to give you the awareness beside his title, lets have a look at them:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Firstly, I didn’t talk to the person who wrote it. I rewrote the code and checked it in without their input. Even if it was an improvement (which I don’t believe anymore), this is a terrible way to go about it&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I think this is the right way you should do when you are truly doing refactoring. You don&amp;rsquo;t have to talk the person directly
if you are doing refactoring, you should be in trust with unit tests. And if the code has a little indicators of clean coding
than you should have general idea why the code is structured like that or your team must have some documentations for exceptions.
What if the person who writes the line leaves the job? You still contact them personally? No, we don&amp;rsquo;t. We make unit &amp;amp; integration tests,
properly structure our code with internally documenting (in our code) and finally we may have externally documentation for exceptional cases.&lt;/p&gt;
&lt;p&gt;And Dan&amp;rsquo;s second mention:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For example, we later needed many special cases and behaviors for different handles on different shapes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When I first read these lines, I say myself &amp;ldquo;finally I will see the point and understand what happened in above code, and
satisfied with his argument in title&amp;rdquo;. It did not happen. He gave me lots of lines above which than I was expecting to see some evidence or
some real results. But instead I read something like &amp;ldquo;special cases&amp;rdquo; which does not give me the idea.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What special cases did he need?&lt;/li&gt;
&lt;li&gt;What should we learn when we refactored like above?&lt;/li&gt;
&lt;li&gt;Which points we should be more careful?&lt;/li&gt;
&lt;li&gt;How did your &amp;ldquo;refactorings&amp;rdquo; are merged, any Pull Request? Who is the reviewer, where is the discussion, did your boss call only you?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As I said before, I know his point. But title, arguments he show and how article is being mentioned in twitter, reddit and
lots of other social medias is dangerous. If you trust that who uses this article has deep knowledge in software principles,
software architectures etc. than we don&amp;rsquo;t have any discussions here. When I start searching if there are some people thinking like me
than I see this 
&lt;a href=&#34;https://www.reddit.com/r/programming/comments/eng355/goodbye_clean_code/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;discussion&lt;/a&gt; on reddit and it
pleased me that they exist.&lt;/p&gt;
&lt;p&gt;If Dan wants to say &amp;ldquo;Great power comes with great responsibility&amp;rdquo;, I agree. But it is already mentioned by Stan Lee and can
be applied in any area of our live with example real life scenarios. If we know all this kind of principles, we should be careful when &amp;amp; where to apply them.
But to get this experience we should first read &amp;amp; get deep knowledge of them, make some mistake and learn from our mistakes.
Otherwise it is too easy for people never read refactoring, clean coding, YAGNI, DRY etc. and only mentioning around this
kind of articles as an excuse of not knowing this principles.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5 Layer and 5 Tier Architecture</title>
      <link>http://cemalonder.com/post/5-layer-and-5-tier-architecture/</link>
      <pubDate>Fri, 13 Sep 2019 08:37:57 +0300</pubDate>
      <guid>http://cemalonder.com/post/5-layer-and-5-tier-architecture/</guid>
      <description>&lt;p&gt;There are differences between N-layer and N-tier definitions. We can start with explaining those first:&lt;/p&gt;
&lt;h2 id=&#34;5-layer-architecture&#34;&gt;5-layer Architecture&lt;/h2&gt;
&lt;p&gt;Layering is logical separation that you implement in your application. It has a relation with N-Tier but we will
move onto it later:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./5-layer.png&#34; alt=&#34;5-layer&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;presentation&#34;&gt;Presentation&lt;/h3&gt;
&lt;p&gt;This is how your application is shown to the user. You can think about it is a look and feel of the application.
But it is very similar to the UI layer, today&amp;rsquo;s world with the improvement of JavaScript (client-side-rendering solutions like React, Angular, etc.) this separation may not be seem exact
but still makes sense, let me continue:&lt;/p&gt;
&lt;h3 id=&#34;ui&#34;&gt;UI&lt;/h3&gt;
&lt;p&gt;This is where user interactions are interpreted. What happens when user clicks submit button, how the data is sent to
the server and retrieved? If you think about server-side rendering which we used older times, we were all interpreting
those and returning user fully ready HTML page but today with client-side-rendering all of those works are done in the
user&amp;rsquo;s browser with the help of JavaScript. So you can think about now Presentation + UI is done in users server
(phone, pc etc.) if client-side-rendering is used. If the user&amp;rsquo;s server is only responsible for showing the data,
now the Presentation layer takes place there while UI layer takes place in our server.&lt;/p&gt;
&lt;h3 id=&#34;business-logic&#34;&gt;Business Logic&lt;/h3&gt;
&lt;p&gt;This is the place where we are responsible for data validation (even if you did it in client-side,
we should do in server-side too because we never trust to clients), manipulation, security, processing,
database lookups, etc. takes place. Those responsibilities can be shared between UI side and Data Access depending
on the action&amp;rsquo;s security scope&lt;/p&gt;
&lt;h3 id=&#34;data-access&#34;&gt;Data Access&lt;/h3&gt;
&lt;p&gt;This is where you abstract to insert, delete, etc. actions that you need to do on the DataBase (Data Storage level).
It kinda interfaces between DataBases and your application&lt;/p&gt;
&lt;h3 id=&#34;data-storage&#34;&gt;Data Storage&lt;/h3&gt;
&lt;p&gt;This is were database servers belong. This is the implementation of the
Data Access layer which psychically inserts, deletes, etc. data on the server.&lt;/p&gt;
&lt;h2 id=&#34;5-tier-architecture&#34;&gt;5-Tier Architecture&lt;/h2&gt;
&lt;p&gt;Now depending on your application&amp;rsquo;s needs, you should define your trade-offs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What do you want to achieve?&lt;/li&gt;
&lt;li&gt;How much do you want to scale?&lt;/li&gt;
&lt;li&gt;What is your acceptable latency?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you achieve low latency and you don&amp;rsquo;t aim to be used by too many users, you can start with 1-tier.
In the below demonstrations keep in mind that the business logic layer can be done in any layers as long as you keep
security reasons, you can have some general/simple business logic in client-side (Presentation/UI layers) too which may
increase your servers performance. Also, you can put UI layer in higher/lower tiers depend on using server-side or
client-side rendering but we talked about general idea above:&lt;/p&gt;
&lt;h3 id=&#34;1-tier&#34;&gt;1-tier&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;./1-tier.png&#34; alt=&#34;1-tier&#34;&gt;&lt;/p&gt;
&lt;p&gt;All layers belong to one physical location. Like a game that installed on the user&amp;rsquo;s database and
doesn&amp;rsquo;t request any other external system, it has own database on the user&amp;rsquo;s server and all logics implemented there.&lt;/p&gt;
&lt;h3 id=&#34;2-tier&#34;&gt;2-tier&lt;/h3&gt;
&lt;p&gt;Lets say you want to central database management and all other parts can remain still user&amp;rsquo;s server, like hes is
playing a game on mobile-phone but data is stored in our servers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./2-tier.png&#34; alt=&#34;2-tier&#34;&gt;&lt;/p&gt;
&lt;p&gt;Up to now, you have a performance advantage. If you need to support more users and need more security
than you need &lt;strong&gt;scalability&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;3-tier&#34;&gt;3-tier&lt;/h3&gt;
&lt;p&gt;Beside microservices (maybe another discussion topic), this is one of the most used architecture.
Presentation and UI is on the user&amp;rsquo;s server (client), business logic and data access belongs to application server,
and data storage is in another server.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./3-tier.png&#34; alt=&#34;3-tier&#34;&gt;&lt;/p&gt;
&lt;p&gt;But now your user&amp;rsquo;s request is jumping more tier&amp;rsquo;s which will increase your network latency.
As talked before it is about trade-offs. Also now you started to have benefit of scaling like:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./3-tier-scaled.png&#34; alt=&#34;3-tier-scaled&#34;&gt;&lt;/p&gt;
&lt;p&gt;So depending on your application needs, security levels, latency limits, user counts etc. You can split it up to
more tiers which is it the reason why its name is N-Tier.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Expert C#2006 Business Objects - Rockford Lhotka&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Software Architecture Patterns - Mark Richards&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
